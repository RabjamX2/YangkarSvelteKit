generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

/// Tracks all stock changes for audit/history purposes
model StockChange {
    id   Int      @id @default(autoincrement())
    date DateTime @default(now())

    productVariantID Int
    variant          ProductVariant @relation(fields: [productVariantID], references: [id])

    change Int // Positive for addition, negative for removal
    reason String?
    user   String? // Optionally, who made the change

    orderId   Int? // Optionally, link to a CustomerOrder or PurchaseOrder
    orderType String? // "customer" or "purchase" or null
}

enum Role {
    USER
    ADMIN
}

model User {
    id       String    @id @default(cuid())
    username String    @unique
    email    String    @unique
    name     String?
    password String
    role     Role      @default(USER)
    sessions Session[]

    passwordResetToken   String?   @unique
    passwordResetExpires DateTime?
}

model Session {
    id        String   @id // This will be our secure session token
    userId    String
    expiresAt DateTime

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// Represents a supplier or seller from whom you purchase goods.
model Supplier {
    id            Int       @id @default(autoincrement())
    idString      String    @unique // e.g., "bt", "ptl"
    name          String    @unique
    tibetanName   String?
    contactPerson String?
    contactMethod String?
    products      Product[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

/// Product categories like "Chupa", "Jewelry", etc.
model Category {
    id       Int       @id @default(autoincrement())
    name     String    @unique
    code     String    @unique // e.g., "chup", "jewe"
    products Product[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

/// Represents the core product concept, like "Metok Wonju" or "plaindhi".
/// Price is stored in the ProductVariant model to allow for differences.
model Product {
    id          Int     @id @default(autoincrement())
    style       String // e.g., "Metok"
    displayName String? // e.g., "Metok Wonju"

    notes String?

    skuIntBase Int?   @unique // e.g., 1001
    skuBase    String @unique // e.g., "ptl_chup_metok"

    // Relationships
    supplierID Int
    supplier   Supplier @relation(fields: [supplierID], references: [id])
    categoryID Int
    category   Category @relation(fields: [categoryID], references: [id])

    variants ProductVariant[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

/// Represents a specific, sellable version of a Product.
/// This is the level where you will track inventory AND price.
model ProductVariant {
    id        Int     @id @default(autoincrement())
    legacySku String? @unique // Old SKU from previous system, e.g., "ptlMetokRedXL"
    sku       String? @unique // specific SKU e.g., "ptl_chup_metok_red_xl"

    color        String?
    displayColor String? // e.g., "Red"
    colorHex     String? // e.g., "#FF0000"

    size   String?
    imgUrl String? @default("/Placeholder4-5.png") // Default image URL

    salePrice Decimal?

    productID Int
    product   Product @relation(fields: [productID], references: [id], onDelete: Cascade)

    purchaseOrderItems PurchaseOrderItem[]
    customerOrderItems CustomerOrderItem[]
    stockChanges       StockChange[]
    inventoryBatches   InventoryBatch[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // This line adds the index to the productSkuBase field for faster lookups.
    @@index([productID])
}

// This model tracks each incoming batch of stock with its specific cost.
model InventoryBatch {
    id Int @id @default(autoincrement())

    productVariantId Int
    productVariant   ProductVariant @relation(fields: [productVariantId], references: [id])

    quantity Int // The remaining quantity in this batch
    costUSD  Decimal?
    costCNY  Decimal?

    createdAt DateTime @default(now())

    purchaseOrderItemId Int               @unique
    purchaseOrderItem   PurchaseOrderItem @relation(fields: [purchaseOrderItemId], references: [id])
}

/// Represents a purchase order made to a Supplier/s.
/// For us, this corresponds to each batch of orders we place
model PurchaseOrder {
    id          Int @id @default(autoincrement())
    batchNumber Int @unique

    shippingCostCny Decimal?
    shippingCostUsd Decimal?

    shipDate   DateTime?
    hasArrived Boolean   @default(false)

    notes String?

    // A purchase order is composed of multiple line items
    items PurchaseOrderItem[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model PurchaseOrderItem {
    id              Int      @id @default(autoincrement())
    quantityOrdered Int
    hasArrived      Boolean? @default(false)
    costPerItemCny  Decimal?
    costPerItemUsd  Decimal?

    PurchaseOrderID Int
    order           PurchaseOrder @relation(fields: [PurchaseOrderID], references: [id])

    ProductVariantID Int
    variant          ProductVariant @relation(fields: [ProductVariantID], references: [id])

    inventoryBatch InventoryBatch?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Customer {
    id     Int             @id @default(autoincrement())
    email  String?         @unique
    name   String?
    phone  String?
    orders CustomerOrder[]

    hasAccount Boolean? @default(false)
    //  if hasAccount is true, link to a User account

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

enum OrderStatus {
    PENDING // Order placed, awaiting payment/fulfillment
    SHIPPED
    COMPLETED
    CANCELLED
    REFUNDED
}

model CustomerOrder {
    id            Int         @id @default(autoincrement())
    invoiceNumber String?     @unique
    orderDate     DateTime    @default(now())
    orderType     String? // e.g., "in-store", "online", etc.
    status        OrderStatus @default(PENDING)
    customerName  String?
    customerPhone String?

    paid Boolean @default(false)

    staffName     String? // Who handled the order
    moneyHolder   String? // Who has the money
    paymentMethod String?
    notes         String?

    customerId Int?
    customer   Customer? @relation(fields: [customerId], references: [id])

    items CustomerOrderItem[]
}

model CustomerOrderItem {
    id        Int      @id @default(autoincrement())
    quantity  Int
    cogs      Decimal?
    salePrice Decimal

    discount Decimal?      @default(0)
    orderId  Int
    order    CustomerOrder @relation(fields: [orderId], references: [id])

    productVariantID Int
    variant          ProductVariant @relation(fields: [productVariantID], references: [id])
}
