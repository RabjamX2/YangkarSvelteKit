generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum OrderType {
    CUSTOMER
    PURCHASE
    MANUAL
}

/// Tracks all stock changes for audit/history purposes
model StockChange {
    id   Int      @id @default(autoincrement())
    date DateTime @default(now())

    productVariantId Int
    variant          ProductVariant @relation(fields: [productVariantId], references: [id])

    change     Int // Positive for addition, negative for removal
    reason     String?
    user       String? // Optionally, who made the change
    changeTime DateTime? @default(now())

    orderId   Int? // Optionally, link to a CustomerOrder or PurchaseOrder
    orderType OrderType?

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

enum Role {
    USER
    ADMIN
}

model User {
    id       String    @id @default(cuid())
    username String    @unique
    email    String    @unique
    name     String?
    password String
    role     Role      @default(USER)
    sessions Session[]

    customer Customer?

    passwordResetToken   String?   @unique
    passwordResetExpires DateTime?

    ordersCreated CustomerOrder[] @relation("OrdersByStaff")

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model Session {
    id        String   @id // This will be our secure session token
    userId    String
    expiresAt DateTime

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
}

/// Represents a supplier or seller from whom you purchase goods.
model Supplier {
    id            Int       @id @default(autoincrement())
    idString      String    @unique // e.g., "bt", "ptl"
    name          String    @unique
    tibetanName   String?
    contactPerson String?
    contactMethod String?
    products      Product[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

/// Product categories like "Chupa", "Jewelry", etc.
model Category {
    id       Int       @id @default(autoincrement())
    name     String    @unique
    code     String    @unique // e.g., "chup", "jewe"
    products Product[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

/// Represents the core product concept, like "Metok Wonju" or "plaindhi".
/// Price is stored in the ProductVariant model to allow for differences.
model Product {
    id          Int     @id @default(autoincrement())
    style       String // e.g., "Metok"
    displayName String? // e.g., "Metok Wonju"

    notes String?

    skuIntBase  Int?    @unique // e.g., 1001
    skuBase     String  @unique // e.g., "ptl_chup_metok"
    barcodeBase String? @unique // e.g., UPC or EAN barcode

    visable Boolean? @default(true) // Whether this product is visible in the catalog

    // Relationships
    supplierId Int
    supplier   Supplier @relation(fields: [supplierId], references: [id])
    categoryId Int
    category   Category @relation(fields: [categoryId], references: [id])

    variants ProductVariant[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

/// Represents a specific, sellable version of a Product.
/// This is the level where you will track inventory AND price.
model ProductVariant {
    id        Int     @id @default(autoincrement())
    legacySku String? @unique // Old SKU from previous system, e.g., "ptlMetokRedXL"
    sku       String? @unique // specific SKU e.g., "ptl_chup_metok_red_xl"
    barcode   String? @unique // e.g., UPC or EAN barcode

    color        String?
    displayColor String? // e.g., "Red"
    colorHex     String? // e.g., "#FF0000"

    visable Boolean? @default(true) // Whether this variant is visible in the catalog

    size   String?
    imgUrl String? @default("/Placeholder4-5.png") // Default image URL

    salePrice Decimal?

    productId Int
    product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

    purchaseOrderItems PurchaseOrderItem[]
    customerOrderItems CustomerOrderItem[]
    stockChanges       StockChange[]
    inventoryBatches   InventoryBatch[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt

    // This line adds the index to the productSkuBase field for faster lookups.
    @@index([productId])
}

// This model tracks each incoming batch of stock with its specific cost.
model InventoryBatch {
    id Int @id @default(autoincrement())

    productVariantId Int
    productVariant   ProductVariant @relation(fields: [productVariantId], references: [id])

    quantity Int // The remaining quantity in this batch
    costUSD  Decimal?
    costCNY  Decimal?

    purchaseOrderItemId Int               @unique
    purchaseOrderItem   PurchaseOrderItem @relation(fields: [purchaseOrderItemId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

/// Represents a purchase order made to a Supplier/s.
/// For us, this corresponds to each batch of orders we place
model PurchaseOrder {
    id          Int @id @default(autoincrement())
    batchNumber Int @unique

    shippingCostCny Decimal?
    shippingCostUsd Decimal?

    usdToCnyRate Decimal? // 1 Usd = X Cny decided at time of order

    extraFeesCny       Decimal?
    extraFeesUsd       Decimal?
    totalPaidUsd       Decimal?
    calculatedTotalUsd Decimal? // Sum of (item cost * quantity)

    shipDate    DateTime?
    arrivalDate DateTime?
    hasArrived  Boolean   @default(false)

    notes String?

    // A purchase order is composed of multiple line items
    items PurchaseOrderItem[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model PurchaseOrderItem {
    id              Int      @id @default(autoincrement())
    quantityOrdered Int
    hasArrived      Boolean? @default(false)
    costPerItemCny  Decimal?
    costPerItemUsd  Decimal?

    purchaseOrderId Int
    order           PurchaseOrder @relation(fields: [purchaseOrderId], references: [id])

    productVariantId Int
    variant          ProductVariant @relation(fields: [productVariantId], references: [id])

    inventoryBatch InventoryBatch?

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model Customer {
    id     Int             @id @default(autoincrement())
    email  String?         @unique
    name   String?
    phone  String?
    orders CustomerOrder[]

    userId String? @unique
    user   User?   @relation(fields: [userId], references: [id])

    addresses Address[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model Address {
    id        Int     @id @default(autoincrement())
    street    String
    city      String
    state     String
    zipCode   String
    country   String
    isDefault Boolean @default(false)

    customerId Int
    customer   Customer @relation(fields: [customerId], references: [id])

    ordersAsShipping CustomerOrder[] @relation("ShippingAddress")
    ordersAsBilling  CustomerOrder[] @relation("BillingAddress")

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

// 1. Define the new, specific enums at the top of your schema
enum PaymentStatus {
    PENDING // Awaiting payment
    PAID // Payment confirmed
    REFUNDED // Payment has been returned
    FAILED // Payment attempt failed
}

enum FulfillmentStatus {
    UNFULFILLED // Paid, but not yet packed
    PROCESSING // In the process of being packed
    SHIPPED // Shipped to the customer
    DELIVERED // Confirmed delivery
    PICKED_UP // Customer picked up in-store
    CANCELLED // The order was cancelled before fulfillment
}

enum ReturnStatus {
    NONE // No return requested
    REQUESTED // Customer has requested a return
    APPROVED // Return approved
    RECEIVED // We have received the returned items
    COMPLETED // Refund or exchange processed
}

enum SalesChannel {
    IN_PERSON // For In-person sales
    ONLINE // For website sales
    SOCIAL // For sales via Instagram, Facebook, etc.
}

enum PaymentMethod {
    CASH
    CREDIT_CARD
    DEBIT_CARD
    ZELLE
    VENMO
    OTHER
}

model CustomerOrder {
    id Int @id @default(autoincrement())

    legacyInvoiceNumber String? @unique
    invoiceNumber       String? @unique

    orderDate    DateTime?     @default(now())
    salesChannel SalesChannel? @default(IN_PERSON)

    paymentStatus     PaymentStatus     @default(PAID)
    fulfillmentStatus FulfillmentStatus @default(PICKED_UP)
    returnStatus      ReturnStatus      @default(NONE)
    paymentMethod     PaymentMethod?
    // TODO: Make paymentMethod non-nullable and always set it

    moneyHolder    String? // Who has the money
    moneyCollected Boolean @default(false) // Has the money been collected from moneyHolder?

    notes String?

    customerName  String?
    customerPhone String?

    // --- Financial Details ---
    // TODO: Make subtotal and total non-nullable and always set them
    subtotal Decimal? // Sum of (salePrice * quantity) for all items
    taxes    Decimal  @default(0) // For future tax calculations
    shipping Decimal  @default(0) // For future shipping costs
    discount Decimal  @default(0) // For order-level discounts (e.g., coupon codes)
    total    Decimal? // The final amount charged to the customer
    paid     Boolean  @default(false)

    // --- Fulfillment Details ---
    shippingMethod String? // e.g., "USPS Priority", "In-Store Pickup"
    trackingNumber String?

    shippingAddressId Int?
    shippingAddress   Address? @relation("ShippingAddress", fields: [shippingAddressId], references: [id])
    billingAddressId  Int? // For separate billing address
    billingAddress    Address? @relation("BillingAddress", fields: [billingAddressId], references: [id])

    // --- Timestamps for Auditing & Analytics ---
    paidAt      DateTime? @default(now()) // When the payment was successfully processed
    fulfilledAt DateTime? @default(now()) // When all items have been shipped/picked up
    cancelledAt DateTime? // When the order was cancelled

    staffId String?
    staff   User?   @relation("OrdersByStaff", fields: [staffId], references: [id])

    customerId Int?
    customer   Customer? @relation(fields: [customerId], references: [id])

    items CustomerOrderItem[]

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}

model CustomerOrderItem {
    id        Int      @id @default(autoincrement())
    quantity  Int
    cogs      Decimal?
    salePrice Decimal

    // --- Product details at the time of sale ---
    // This ensures we have a historical record even if the product or variant changes later
    productName String? // e.g., "Metok Wonju"
    productSku  String? // e.g., "ptl_wonj_metok_red_xl"

    isPreOrder Boolean @default(false)

    discount Decimal?      @default(0)
    orderId  Int
    order    CustomerOrder @relation(fields: [orderId], references: [id])

    productVariantId Int
    variant          ProductVariant @relation(fields: [productVariantId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @default(now()) @updatedAt
}
